-- TO-DO: Tighten up logic for returning/incrementing UserId values
CREATE OR REPLACE FUNCTION $DB_NAME$Views.SP_DCPUpsertUser (
    pUserId INTEGER, 
    pUserName VARCHAR(50), 
    pUserType CHAR(1), 
    pFirstName VARCHAR(100), 
    pLastName VARCHAR(100), 
    pSignatureScanFile BYTEA,
    pPhoneNumber VARCHAR(25),
    pEmailAddress VARCHAR(250),
    pPassword VARCHAR(128),
    pLast_Login TIMESTAMPTZ
) 
RETURNS INTEGER AS
$$
DECLARE NewUserId INTEGER; -- Track how many new users were created
BEGIN   
        
    -- Get new userid
    SELECT NextValue INTO NewUserId
    FROM $DB_NAME$.NextId
    WHERE IdType = 'User'
    FOR UPDATE; -- Use "Update" row-lock so it is not read by any other queries also using "Update" row-lock
    
    -- Merge in new user
    INSERT INTO $DB_NAME$.Users(UserId, UserName, UserType, FirstName, LastName, DefaultSignatureScanFile, PhoneNumber, EmailAddress, Password, Last_Login)
    VALUES(COALESCE(pUserId, NewUserId), pUserName, pUserType, pFirstName, pLastName, pSignatureScanFile, pPhoneNumber, pEmailAddress, pPassword, pLast_Login)
    ON CONFLICT(UserId) DO UPDATE SET
	    FirstName = EXCLUDED.FirstName,
	    LastName = EXCLUDED.LastName,
	    DefaultSignatureScanFile = EXCLUDED.DefaultSignatureScanFile,
        UserName = EXCLUDED.UserName,
        UserType = EXCLUDED.UserType,
	    PhoneNumber = EXCLUDED.PhoneNumber,
	    EmailAddress = EXCLUDED.EmailAddress,
	    Password = COALESCE(EXCLUDED.Password, Users.Password), -- If no value provided, keep existing one (i.e. don't allow NULL once set)
	    Last_Login = COALESCE(EXCLUDED.Last_Login, Users.Last_Login) -- If no value provided, keep existing one (i.e. don't allow NULL once set)
    ;   
    
    -- Increment UserId value
    UPDATE $DB_NAME$.NextId
    SET NextValue = NextValue + CASE WHEN pUserId IS NULL THEN 1 ELSE 0 END
    WHERE IdType = 'User'
    ;   
    
    RETURN NewUserId;   
END;
$$
LANGUAGE 'plpgsql';