CREATE OR REPLACE FUNCTION $APP_NAME$Views.SP_DCPModifyContractParties(
    pContractId INTEGER,
    pPartyUserInfo JSONB
)
RETURNS INTEGER AS $$
BEGIN
	
    -- Delete old parties (if applicable)
    IF(pPartyUserInfo->'deletedparties') IS NOT NULL THEN
        DELETE FROM $APP_NAME$.Contract_Party_Approval
        WHERE ContractId = pContractId
        AND PartyUserId IN (
            SELECT CAST(
                JSONB_ARRAY_ELEMENTS_TEXT(pPartyUserInfo->'deletedparties') AS INTEGER
            )
        )
        ;
    
        DELETE FROM $APP_NAME$.Contract_Party
        WHERE ContractId = pContractId
        AND PartyUserId IN (
            SELECT CAST(
                JSONB_ARRAY_ELEMENTS_TEXT(pPartyUserInfo->'deletedparties') AS INTEGER
            )
        )
        ;
    END IF;
    
    -- Update current parties (if applicable)
    IF(pPartyUserInfo->'currentparties') IS NOT NULL THEN 
	    INSERT INTO $APP_NAME$.Contract_Party (ContractId, PartyUserId, ContractRole, GroupInfo)
		SELECT pContractId AS ContractId, src.PartyUserId, src.ContractRole, ug.GroupInfo
		FROM JSONB_TO_RECORDSET(pPartyUserInfo->'currentparties') 
		   AS src (PartyUserId INTEGER, ContractRole CHAR(2))
		INNER JOIN $APP_NAME$Views.Users u ON src.PartyUserId = u.UserId -- Only include users that are already registered
		LEFT JOIN (
			SELECT ug.GroupUserId, TO_JSONB(
				(
				SELECT x 
				FROM (
					SELECT ug.GroupUserId, ug.GroupName, ug.ClassId, ug.LeaderUserId, ug.UserIdList, ul.FirstName AS LeaderFirstName, ul.LastName AS LeaderLastName
				) AS x) 
			) AS GroupInfo
			FROM $APP_NAME$Views.User_Group ug
			INNER JOIN $APP_NAME$Views.Users ul ON ug.LeaderUserId = ul.UserId
		) ug ON u.UserId = ug.GroupUserId -- Get group info
		ON CONFLICT (ContractId, PartyUserId) DO UPDATE SET 
			ContractRole = EXCLUDED.ContractRole,
			GroupInfo = EXCLUDED.GroupInfo
		;
	END IF;
	    	
	-- Return contractId
    RETURN pContractId;
END
$$ LANGUAGE 'plpgsql';
