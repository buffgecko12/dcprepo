CREATE OR REPLACE FUNCTION $DB_NAME$Views.SP_DCPUpsertContract(
    pContractId INTEGER,
    pClassId INTEGER,
    pContractType CHAR(1),
    pTeacherUserId INTEGER,
    pContractValidPeriod TSTZRANGE,
    pGuardianSignatureFlag BOOLEAN,
    pRevisionDeadlineTS TIMESTAMP WITH TIME ZONE,
    pRevisionDescription VARCHAR(500),
    pStudentLeaderRequirements VARCHAR(500),
    pTeacherRequirements VARCHAR(500),
    pStudentRequirements VARCHAR(500),
    pContractScanFile BYTEA,
    pGoalInfo JSONB,
    pRewardInfo JSONB,
    pPartyInfo JSONB
) 
RETURNS INTEGER AS $$
DECLARE
	MyContractId INTEGER;
BEGIN
	
	-- S0: SETUP
	-- S0a: Get userid
	IF(pContractId IS NULL) THEN
		-- Create contract (get new id)
	    SELECT * FROM SP_DCPGetNextId('contract') INTO MyContractId;
    ELSE
    	-- Update contract (use provided id)
    	MyContractId = pContractId;
    END IF;

	-- S1: GENERAL
	-- S1a: Upsert general info
	INSERT INTO $DB_NAME$.Contract (ContractId, ClassId, ContractType, TeacherUserId, ContractValidPeriod, GuardianSignatureFlag, 
	  RevisionDeadlineTS, RevisionDescription, StudentLeaderRequirements, TeacherRequirements, StudentRequirements, ContractScanFile)
    VALUES(MyContractId, pClassId, pContractType, pTeacherUserId, pContractValidPeriod, pGuardianSignatureFlag, pRevisionDeadlineTS, 
      pRevisionDescription, pStudentLeaderRequirements, pTeacherRequirements, pStudentRequirements, pContractScanFile)
    ON CONFLICT (ContractId) DO UPDATE SET
        ClassId = EXCLUDED.ClassId,
        ContractType = EXCLUDED.ContractType,
        TeacherUserId = EXCLUDED.TeacherUserId,
	    ContractValidPeriod = EXCLUDED.ContractValidPeriod,
	    GuardianSignatureFlag = EXCLUDED.GuardianSignatureFlag,
	    RevisionDeadlineTS = EXCLUDED.RevisionDeadlineTS,
		RevisionDescription = EXCLUDED.RevisionDescription,
	    StudentLeaderRequirements = EXCLUDED.StudentLeaderRequirements,
	    TeacherRequirements = EXCLUDED.TeacherRequirements,
	    StudentRequirements = EXCLUDED.StudentRequirements,
	    ContractScanFile = EXCLUDED.ContractScanFile
    ;

    -- S2: GOALS
    -- S2a: Delete old goals (if applicable)
    IF(pGoalInfo->'deletedgoals') IS NOT NULL THEN
        DELETE FROM $DB_NAME$.Contract_Goal
        WHERE ContractId = MyContractId
        AND GoalId IN (
            SELECT CAST(
                JSONB_ARRAY_ELEMENTS_TEXT(pGoalInfo->'deletedgoals') AS INTEGER
            )
        )
        ;
    END IF;
    
    -- S2b: Update current goals
    INSERT INTO $DB_NAME$.Contract_Goal (ContractId, GoalId, DifficultyLevel, GoalDescription, AchievedFlag)
	SELECT 
        MyContractId,
        COALESCE(
            src.GoalId, -- Use original GoalId if provided (otherwise generate new one)
            COALESCE((SELECT MAX(GoalId) FROM $DB_NAME$.Contract_Goal WHERE ContractId = MyContractId), 0) + -- Get max GoalId for this contract
            ROW_NUMBER() OVER(PARTITION BY src.GoalId /* GROUP NULLs (new goals) into same partition */ ORDER BY src.GoalId) -- Generate new GoalId values
        ) AS NewGoalId,
        src.DifficultyLevel,
	    src.GoalDescription, 
	    src.AchievedFlag
	FROM JSONB_TO_RECORDSET(pGoalInfo->'currentgoals')
	  AS src(
	   goalId INTEGER, 
	   DifficultyLevel CHAR(1),
	   GoalDescription VARCHAR(500), 
	   AchievedFlag BOOLEAN
   ) -- Be careful with case-sensitivity with PG (use all lower-case values in JSON to be safe)    
    ON CONFLICT (ContractId, GoalId) DO UPDATE SET 
		DifficultyLevel = EXCLUDED.DifficultyLevel,
        GoalDescription = EXCLUDED.GoalDescription,
        AchievedFlag = EXCLUDED.AchievedFlag -- "excluded" stores rows that could not be inserted
    ;
    
    -- S3: REWARDS
    -- S3a: Delete old rewards (if applicable)
    IF(pRewardInfo->'deletedrewards') IS NOT NULL THEN
        DELETE FROM $DB_NAME$.Contract_Reward
        WHERE ContractId = MyContractId
        AND RewardId IN (
            SELECT CAST(
                JSONB_ARRAY_ELEMENTS_TEXT(pRewardInfo->'deletedrewards') AS INTEGER
            )
        )
        ;
    END IF;
    
    -- S3b: Update current rewards
    INSERT INTO $DB_NAME$.Contract_Reward (ContractId, RewardId, DifficultyLevel, RewardDescription)
	SELECT 
        MyContractId,
        COALESCE(
            src.RewardId, -- Use original RewardId if provided (otherwise generate new one)
            COALESCE((SELECT MAX(RewardId) FROM $DB_NAME$.Contract_Reward WHERE ContractId = MyContractId), 0) + -- Get max RewardId for this contract
            ROW_NUMBER() OVER(PARTITION BY src.RewardId /* GROUP NULLs (new rewards) into same partition */ ORDER BY src.RewardId) -- Generate new RewardId values
        ) AS NewRewardId,
        src.DifficultyLevel,
	    src.RewardDescription
	FROM JSONB_TO_RECORDSET(pRewardInfo->'currentrewards')
	  AS src(
	   rewardId INTEGER, 
	   DifficultyLevel CHAR(1),
	   RewardDescription VARCHAR(500)
   ) -- Be careful with case-sensitivity with PG (use all lower-case values in JSON to be safe)    
    ON CONFLICT (ContractId, RewardId) DO UPDATE SET 
		DifficultyLevel = EXCLUDED.DifficultyLevel,
        RewardDescription = EXCLUDED.RewardDescription -- "excluded" stores rows that could not be inserted
    ;
    
    
	-- S4: PARTIES
    -- S4a: Delete old parties (if applicable)
    IF(pPartyInfo->'deletedparties') IS NOT NULL THEN
        DELETE FROM $DB_NAME$.Contract_Party
        WHERE ContractId = MyContractId
        AND PartyUserId IN (
            SELECT CAST(
                JSONB_ARRAY_ELEMENTS_TEXT(pPartyInfo->'deletedparties') AS INTEGER
            )
        )
        ;
    END IF;

    -- S4b: Update current parties
    INSERT INTO $DB_NAME$.Contract_Party (ContractId, PartyUserId, ContractRole)
	SELECT MyContractId AS ContractId, src.PartyUserId, src.ContractRole
	FROM JSONB_TO_RECORDSET(pPartyInfo->'currentparties') 
	   AS src (PartyUserId INTEGER, ContractRole CHAR(2))
	INNER JOIN $DB_NAME$Views.Users u ON src.PartyUserId = u.UserId -- Only include users that are already registered
	ON CONFLICT (ContractId, PartyUserId) DO UPDATE SET 
		ContractRole = EXCLUDED.ContractRole
	;
	
	-- Return contractId
    RETURN MyContractId;
END
$$ LANGUAGE 'plpgsql';
